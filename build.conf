# shellcheck shell=bash disable=SC2034

ARCH_YAML='arch.yaml'

# SOURCE_REPO='moonbuggy2000/alpine-s6-python'
SOURCE_REPO='python'
SOURCE_ARCH_PREFIX='true'

# Alpine has no cargo or rust packages for s390x
EXCLUDED_ARCHES='s390x'

# no need to combine thigns into multi-arch tags for this project
NO_MANIFEST=1

# local output directory for build wheels
WHEELS_OUT='wheels'

# don't pull self image at pre_build
# NO_SELF_PULL=1

# force pulling in pre_build even if image already exists locally
# WHEELS_FORCE_PULL=1

# use source, not pre compiled binary wheels
# NO_BINARY=1

# default modules to import for all builds
DEFAULT_MODULE_IMPORTS='auditwheel cffi pycparser toml'

DEFAULT_SSL='openssl'

CACHE_EXPIRY=86400

# don't get versions from this repo in python_get_module_from_string, use PyPi only
# otherwise we'd need to specify version numbers to build newer than we've built
# before, this allows us to build latest versions from PyPi by default when no
# version is specific in the build arguments
NO_MUSL_WHEEL_REPO=1

declare -A BUILD_ARGS=( \
	[BUILD_PYTHON_VERSION]='Python version' \
	[DEFAULT_MODULES]='Default modules' \
	[QEMU_DIR]='QEMU directory' \
	[MODULE_NAME]='Module name' \
	[MODULE_VERSION]='Module version' \
	[MODULE_ENV]='Module env' \
	[SSL_LIBRARY]='SSL library' \
	[IMPORTS_DIR]='Imports dir' \
	[PYTHON_ARCH_TAG]='Python arch tag' \
	[TARGET_ARCH_TAG]='Target arch' \
	[NO_BINARY]='Build from source' \
)

declare -A CHECKOUT_DISPLAY=( \
	[MODULE_NAME]='Module name' \
	[MODULE_LONG_NAME]='Module long name' \
	[MODULE_VERSION]='Module version' \
	[BUILD_PYTHON_VERSION]='Python version' \
	[PYTHON_LATEST]='Python latest' \
	[QEMU_PREFIX]='QEMU prefix' \
	[WHEEL_TAGS]='Wheel imports' \
	[SSL_LIBRARY]='SSL library' \
)

post_checkout_start () {
	BUILD_PYTHON_VERSION="$(echo ${DOCKER_TAG} | grep -oP '(?<=-py)[0-9.]*')"

	[ -z "${PYTHON_LATEST}" ] \
		&& PYTHON_LATEST="$(docker_api_repo_tags "${SOURCE_REPO}" | grep -oP "^[0-9.]*(?=-alpine)" | sort -uV | tail -n1)"
	add_param "${PYTHON_LATEST}" 'PYTHON_LATEST'

	# default to latest version if none is specified
	[ -z "${BUILD_PYTHON_VERSION}" ] && BUILD_PYTHON_VERSION="${PYTHON_LATEST}"

	# ..which is 2.7 if only '2' has been specified
	[ "x${BUILD_PYTHON_VERSION}" = 'x2' ] && BUILD_PYTHON_VERSION='2.7'

	# don't care about the full version, we'll just use X.Y instead of X.Y.Z
	add_param "$(echo ${BUILD_PYTHON_VERSION} | awk -F \. '{print $1"."$2}')" 'BUILD_PYTHON_VERSION'

	# auditwheel isn't compatible with Python 2.7
	[ "x${BUILD_PYTHON_VERSION}" = "x2.7" ] \
		&& DEFAULT_MODULE_IMPORTS="${DEFAULT_MODULE_IMPORTS//auditwheel/}"

	# we should use the oldest possible Alpine version, to ensure the wheels are
	# compatible with containers using older versions of Alpine. however, we need to
	# be in at least Alpine 3.13 to get a new enough rust version to build
	# 'cryptography' successfully. This means we're going to be building wheels with
	# musl 1.2, and won't be compatible with musl 1.1 in Alpine 3.12 and earlier.
	MINIMUM_ALPINE_VERSION='3.13'

	add_param "$(docker_api_repo_tags ${SOURCE_REPO} | grep -oP "^${BUILD_PYTHON_VERSION}-alpine\K[0-9.]+$")" 'SOURCE_ALPINE_VERSIONS'

	for alpine_version in ${SOURCE_ALPINE_VERSIONS}; do
		if [ "$(printf '%s\n' "${MINIMUM_ALPINE_VERSION}" "${alpine_version}" | sort -V | head -n1)" = "${MINIMUM_ALPINE_VERSION}" ]; then
			BUILD_ALPINE_VERSION="${alpine_version}"
			break
		fi
	done

	# if we can't meet the minimum Alpine version go with the highest available
	[ -z "${BUILD_ALPINE_VERSION}" ] \
		&& BUILD_ALPINE_VERSION="$(echo ${SOURCE_ALPINE_VERSIONS} | xargs -n1 | tail -n1)"

	add_param "${BUILD_ALPINE_VERSION}" 'BUILD_ALPINE_VERSION'

	SOURCE_TAG="${BUILD_PYTHON_VERSION}-alpine${BUILD_ALPINE_VERSION}"

	# if we want to use 'alpine' as a source image rather than 'python', we'll need
	# to map versions:
	#
	# case ${BUILD_PYTHON_VERSION} in
	# 	'3.6') ALPINE_VERSION='3.9' ;;
	# 	'3.7') ALPINE_VERSION='3.10' ;;
	# 	'3.8') ALPINE_VERSION='3.13' ;;
	# 	'3.9') ALPINE_VERSION='3.14' ;;
	# 	*) ALPINE_VERISON='3.14' ;;
	# esac

	#	expect tags in the form: <module_name><module_versio>-py<python version>-<arch>
	#	e.g.	cryptography3.4.6-py3.8-arm

	# for this repo, NO_MUSL_WHEEL_REPO needs to be set
	MODULE_NAMEVER="$(python_get_module_from_string "${DOCKER_TAG}")"

	# strip trailing version number from MODULE_NAMEVER
	add_param "$(echo ${MODULE_NAMEVER} | sed -E 's|([0-9.]*)$||')" 'MODULE_LONG_NAME'

	case "${MODULE_LONG_NAME##*-}" in
		libressl|openssl)
			add_param "${MODULE_LONG_NAME##*-}" 'SSL_LIBRARY' 'SSL library'
			MODULE_NAME="${MODULE_LONG_NAME%-*}"
			;;
		*)
			add_param "${DEFAULT_SSL}" 'SSL_LIBRARY' 'SSL library'
			MODULE_NAME="${MODULE_LONG_NAME}"
			;;
	esac
	add_param "${MODULE_NAME}" 'MODULE_NAME' 'Module'

	add_param "${MODULE_NAMEVER//*[^0-9.]/}" 'MODULE_VERSION'

	# cryptography isn't working on ppc64le in Alpine 3.12
	# if [ "${MODULE_NAME}" = 'cryptography' ] && \
	# 	[ "$(printf '%s\n' '3.12' "${BUILD_ALPINE_VERSION}" | sort -V | tail -n1)" = '3.12' ]; then
	# 	# if we're building ppc64le-only use Alpine >= 3.13
	# 	if [ "x${DOCKER_TAG##*-}" = "xppc64le" ]; then
	# 		for alpine_version in ${SOURCE_ALPINE_VERSIONS}; do
	# 			if [ "$(printf '%s\n' "3.13" "${alpine_version}" | sort -V | head -n1)" = "3.13" ]; then
	# 				BUILD_ALPINE_VERSION="${alpine_version}"
	# 				break
	# 			fi
	# 		done
	# 	# otherwise exclude ppc64le from Alpine <= 3.12 multi-arch builds
	# 	elif [ "$(printf '%s\n' '35.0.0' "${MODULE_VERSION}" | sort -V | head -n1)" = '35.0.0' ]; then
	# 			EXCLUDED_ARCHES="${EXCLUDED_ARCHES} ppc64le"
	# 	fi
	# fi

	TARGET_TAG="${MODULE_LONG_NAME}${MODULE_VERSION}-py${BUILD_PYTHON_VERSION}"

	# if there's a script for this module then source it
	MODULE_SCRIPT="./scripts/${MODULE_NAME}.sh"
	# shellcheck disable=SC1090
	[ -f "${MODULE_SCRIPT}" ] && . "${MODULE_SCRIPT}"
}

post_checkout_end () {
	# Grab any dependencies we've already built
	#
	# This is useful to speed up images we've not built before.
	#

	# if there's a script for this module get dependencies from mod_depends()
	ifFuncSetVar 'MODULE_IMPORTS' 'mod_depends'

	MODULE_IMPORTS="${DEFAULT_MODULE_IMPORTS} ${MODULE_IMPORTS}"

	[ -z "${NO_SELF_PULL+set}" ] \
		&& MODULE_IMPORTS="${MODULE_LONG_NAME}${MODULE_VERSION} ${MODULE_IMPORTS}"

	# WHEEL_TAGS are the wheels to pull from this repo during pre-build
	WHEEL_TAGS=''
	for module in ${MODULE_IMPORTS}; do
		WHEEL_TAGS="$(python_get_module_from_string "${module}") ${WHEEL_TAGS}"
	done
	add_param "$(echo ${WHEEL_TAGS} | xargs -n1 | sort -uV | xargs)" 'WHEEL_TAGS'

	# get version for default wheels, default to the latest version in this repo
	# and fallback to PyPi if it doesn't exist
	# DEFAULT_MODULES is used during build in the Dockerfile
	[ -z "${DEFAULT_MODULES}" ] && for module in ${DEFAULT_MODULE_IMPORTS}; do
		modver="$(py_musl_wheel_latest ${module})"
		[ -z "${modver}" ] && modver="$(pypi_api_latest_version ${module})"
		DEFAULT_MODULES="${module}==${modver} ${DEFAULT_MODULES}"
	done
	add_param "${DEFAULT_MODULES}" 'DEFAULT_MODULES'
}

post_build () {
	echo '--- post_build (from build.conf) ---'

	[ -z "${BUILD_KEEP_IMPORTS+set}" ] \
		&& rm -rf _dummyfile "${IMPORTS_DIR}" "${QEMU_DIR}" > /dev/null 2>&1

	[ -z "${WHEELS_OUT}" ] \
		&& echo "No wheels output directory defined." \
		&& return
	[ -n "${SSL_LIBRARY+set}" ] && [ "${SSL_LIBRARY}" != "${DEFAULT_SSL}" ] \
		&& echo "Not outputting wheels for ${SSL_LIBRARY} build." \
		&& return

	echo "Copying built wheels to: ${WHEELS_OUT}/"
	[ -d "${WHEELS_OUT}" ] || mkdir -p "${WHEELS_OUT}"

	for arch in ${build_arches:-}; do
		for key in ${available_keys:-}; do
			var="${arch}_${key}"
			declare "${key}=${!var}"
		done

		[ ! -d "${WHEELS_OUT}/${arch}" ] && mkdir -p "${WHEELS_OUT}/${arch}"

		local image && image="${DOCKER_REPO}:${TARGET_TAG}-${TARGET_ARCH_TAG}"
		echo "Copying: ${image}"

		[ -n "${NOOP+set}" ] && echo '[NOOP]' && continue
		docker save "${image}" | tar --wildcards -xf - -O -- */layer.tar | tar -ixf - -C "${WHEELS_OUT}/${arch}/"
		rm -rf "${WHEELS_OUT}/${arch}/.arch" >/dev/null 2>&1 || true
	done
}

 get_base_tags () {
	[ "${MODULE_LONG_NAME}" != "${MODULE_NAME}" ] && \
		[ "${MODULE_LONG_NAME##*-}" = "${DEFAULT_SSL}" ] \
		&& echo "${TARGET_TAG}" | sed "s/${MODULE_LONG_NAME}/${MODULE_NAME}/"
 }
