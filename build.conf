# shellcheck shell=bash disable=SC2034

ARCH_YAML="arch.yaml"

#SOURCE_REPO='moonbuggy2000/alpine-s6-python'
SOURCE_REPO='python'
SOURCE_ARCH_PREFIX='true'

# Alpine has no cargo or rust packages for s390x
EXCLUDED_ARCHES='s390x'

# no need to combine thigns into multi-arch tags for this project
NO_MANIFEST=1

# local output directory for build wheels
WHEELS_OUT="wheels"

# don't pull self image at pre_build
#NO_PULL_SELF=1

# force pulling in pre_build even if image already exists locally
#WHEELS_FORCE_PULL=1

# default modules to import for all builds
DEFAULT_MODULE_IMPORTS='cffi pycparser toml'

DEFAULT_SSL='openssl'

declare -A BUILD_ARGS=( \
	[BUILD_PYTHON_VERSION]='Python version' \
	[DEFAULT_MODULES]='Default modules' \
	[QEMU_DIR]='QEMU directory' \
	[MODULE_NAME]='Module name' \
	[MODULE_VERSION]='Module version' \
	[MODULE_ENV]='Module env' \
	[SSL_LIBRARY]='SSL library' \
	[IMPORTS_DIR]='Imports dir' \
	[PYTHON_ARCH_TAG]='Python arch tag' \
	[TARGET_ARCH_TAG]='Target arch' \
)

declare -A CHECKOUT_DISPLAY=( \
	[MODULE_NAME]='Module name' \
	[MODULE_LONG_NAME]='Module long name' \
	[MODULE_VERSION]='Module version' \
	[BUILD_PYTHON_VERSION]='Python version' \
	[PYTHON_LATEST]='Python latest' \
	[QEMU_PREFIX]='QEMU prefix' \
	[WHEEL_TAGS]='Wheel imports' \
	[SSL_LIBRARY]='SSL library' \
)

post_checkout_start () {
	BUILD_PYTHON_VERSION="$(echo ${DOCKER_TAG} | grep -oP '(?<=-py)[0-9.]*')"

	[ -z "${PYTHON_LATEST}" ] \
		&& add_param "$(docker_api_repo_tags "${SOURCE_REPO}" \
			| grep -oP "^[0-9.]*(?=-${TARGET_SOURCE_TAG})" | sort -uV | tail -n1)" 'PYTHON_LATEST'

	# default to latest version if none is specified
	[ -z "${BUILD_PYTHON_VERSION}" ] && BUILD_PYTHON_VERSION="${PYTHON_LATEST}"

	# ..which is 2.7 if only '2' has been specified
	[ "x${BUILD_PYTHON_VERSION}" = 'x2' ] && BUILD_PYTHON_VERSION='2.7'

	# don't care about the full version, we'll just use X.Y instead of X.Y.Z
	add_param "$(echo ${BUILD_PYTHON_VERSION} | awk -F \. '{print $1"."$2}')" 'BUILD_PYTHON_VERSION'

	SOURCE_TAG="${BUILD_PYTHON_VERSION}-alpine"

	# if we want to use 'alpine' as a source image rather than 'python', we'll need
	# to map versions:
	#
	# case ${BUILD_PYTHON_VERSION} in
	# 	'3.6') ALPINE_VERSION='3.9' ;;
	# 	'3.7') ALPINE_VERSION='3.10' ;;
	# 	'3.8') ALPINE_VERSION='3.13' ;;
	# 	'3.9') ALPINE_VERSION='3.14' ;;
	# 	*) ALPINE_VERISON='3.14' ;;
	# esac

	#	expect tags in the form: <module_name><module_versio>-py<python version>-<arch>
	#	e.g.	cryptography3.4.6-py3.8-arm

	MODULE_NAMEVER="$(python_get_module_from_string "${DOCKER_TAG}")"
	MODULE_LONG_NAME="${MODULE_NAMEVER%%[0-9.]*}"
	add_param "${MODULE_LONG_NAME%-}" 'MODULE_LONG_NAME'

	case "${MODULE_LONG_NAME##*-}" in
		libressl|openssl)
			add_param "${MODULE_LONG_NAME##*-}" 'SSL_LIBRARY' 'SSL library'
			MODULE_NAME="${MODULE_LONG_NAME%-*}"
			;;
		*)
			add_param "${DEFAULT_SSL}" 'SSL_LIBRARY' 'SSL library'
			MODULE_NAME="${MODULE_LONG_NAME}"
			;;
	esac
	add_param "${MODULE_NAME%-}" 'MODULE_NAME' 'Module'

	MODULE_VERSION="${MODULE_NAMEVER//*[^0-9.]/}"
	[ -z "${MODULE_VERSION}" ] && MODULE_VERSION="$(pypi_api_latest_version ${MODULE_NAME})"
	add_param "${MODULE_VERSION}" 'MODULE_VERSION' 'Module version'

	TARGET_TAG="${MODULE_NAMEVER}-py${BUILD_PYTHON_VERSION}"

	# if there's a script for this module then source it
	MODULE_SCRIPT="./scripts/${MODULE_NAME}.sh"
	# shellcheck disable=SC1090
	[ -f "${MODULE_SCRIPT}" ] \
		&& . "${MODULE_SCRIPT}"
}

post_checkout_end () {
	# Grab any dependencies we've already built
	#
	# This is useful to speed up images we've not built before. The self-import feature will take
	# care of this for non-virgin builds.
	#

	# if there's a script for this module get dependencies from mod_depends()
	ifFuncSetVar 'MODULE_IMPORTS' 'mod_depends'

	MODULE_IMPORTS="${DEFAULT_MODULE_IMPORTS} ${MODULE_IMPORTS}"

	[ -z "${NO_SELF_PULL+set}" ] && \
		MODULE_IMPORTS="${MODULE_LONG_NAME}${MODULE_VERSION} ${MODULE_IMPORTS}"

	WHEEL_TAGS=''
	for module in ${MODULE_IMPORTS}; do
		WHEEL_TAGS="$(python_get_module_from_string "${module}") ${WHEEL_TAGS}"
	done
	add_param "$(echo ${WHEEL_TAGS} | xargs -n1 | sort -uV | xargs)" 'WHEEL_TAGS'

	# Provide module version for defaults. Without versions in this string it may
	# pull and build from source even if the wheel is provided
	[ -z "${DEFAULT_MODULES}" ] && for module in ${DEFAULT_MODULE_IMPORTS}; do
		DEFAULT_MODULES="${module}==$(pypi_api_latest_version ${module}) ${DEFAULT_MODULES}"
	done
	add_param "${DEFAULT_MODULES}" 'DEFAULT_MODULES'
}

post_build () {
	echo '--- post_build (from build.conf) ---'

	[ -z "${BUILD_KEEP_IMPORTS+set}" ] \
		&& rm -rf _dummyfile "${IMPORTS_DIR}" "${QEMU_DIR}" > /dev/null 2>&1

	[ -z "${WHEELS_OUT}" ] \
		&& echo "No wheels output directory defined." \
		&& return
	[ -n "${SSL_LIBRARY+set}" ] && [ "${SSL_LIBRARY}" != "${DEFAULT_SSL}" ] \
		&& echo "Not outputting wheels for ${SSL_LIBRARY} build." \
		&& return

	echo "Copying built wheels to: ${WHEELS_OUT}/"
	[ -d "${WHEELS_OUT}" ] || mkdir -p "${WHEELS_OUT}"

	for arch in ${build_arches:-}; do
		for key in ${available_keys:-}; do
			var="${arch}_${key}"
			declare "${key}=${!var}"
		done

		[ ! -d "${WHEELS_OUT}/${arch}" ] && mkdir -p "${WHEELS_OUT}/${arch}"

		local image && image="${DOCKER_REPO}:${TARGET_TAG}-${TARGET_ARCH_TAG}"
		echo "Copying: ${image}"

		[ -n "${NOOP+set}" ] && echo '[NOOP]' && continue
		docker save "${image}" | tar --wildcards -xf - -O -- */layer.tar | tar -ixf - -C "${WHEELS_OUT}/${arch}/"
		rm -rf "${WHEELS_OUT}/${arch}/.arch" >/dev/null 2>&1 || true
	done
}

 get_base_tags () {
	[ "${MODULE_LONG_NAME}" != "${MODULE_NAME}" ] && \
		[ "${MODULE_LONG_NAME##*-}" = "${DEFAULT_SSL}" ] \
		&& echo "${TARGET_TAG}" | sed "s/${MODULE_LONG_NAME}/${MODULE_NAME}/"
 }
